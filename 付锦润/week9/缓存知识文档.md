# 缓存知识文档

## 1.缓存的基本概念

缓存(Cache)可以分为硬件缓存和**软件缓存**，硬件缓存位于 CPU 与内存之间，下面仅介绍软件缓存。

### 1.1 定义

缓存是指在软件应用中使用**快速存储介质（如内存、硬盘）**来保存经常访问的数据，
以避免每次访问都需要从较慢的存储介质（如远程服务器）读取。

### 1.2 目的

- **提高性能**：减少数据读取的延迟，加快数据访问速度。
- **降低负载**：减轻后端存储系统的压力，提升系统的整体响应能力。

### 1.3 种类

缓存可以存在于不同的级别，下面介绍3种缓存。

1. 内存缓存
   - 优：数据存储在 RAM 中，速度远高于硬盘或其他非易失性存储介质。
   - 缺：时效性短，容量小，受应用进程影响。
2. 硬盘缓存
   - 优：时效性更长，容量大，不受应用进程影响。
   - 缺：数据存储在硬盘中，速度比内存缓存慢，需要重新解析文件进行I/O操作。
3. 分布式缓存
   - 优：容量大，不受应用进程影响，数据一致性，读写分离，高可用，可拓展。
   - 缺：缓存数据分布在多个节点上，需要数据跨网络传输，性能低于本地缓存。

## 2.Java标准库缓存

对于分布式缓存(如 Redis )而言，因为其存在网络 io 及流量消耗等问题需要和**本地缓存**搭配使用，
所以下面介绍 Java 标准库中的缓存(属于**本地缓存**)。

1. Map、LinkedHashMap、HashMap、Queue等
   - 可以实现一些简单的缓存结构，有些还可以实现一些缓存策略，如FIFO。
2. ConcureentHashMap
   - 作为一个线程安全的 Map 实现，适用于并发环境中的数据存储，可以构建自定义的缓存策略。

## 3.常用缓存框架

除了 Java 标准库中的缓存之外，还有一些 Java 缓存框架，
它们作为独立的第三方库提供了比 Java 标准库**更丰富的缓存功能**和**更高效的缓存实现**。

### 3.1 [Guava Cache](https://guava.dev/)

- 使用场景：适用于中等规模、需要灵活过期策略的缓存需求的应用程序。

- 优点：对于中等规模的缓存需求性能良好。

- 缺点：功能有限，不支持持久化和分布式缓存。

- 配置方式：
  ```java
  LoadingCache<String, Integer> cache = CacheBuilder.newBuilder()
          .maximumSize(100)  // 最大缓存容量
          .expireAfterWrite(10, TimeUnit.MINUTES)  // 写入后10分钟过期
          .expireAfterAccess(5, TimeUnit.MINUTES)  // 最后一次访问后5分钟过期
          .concurrencyLevel(4)  // 允许4个线程同时访问缓存
          .refreshAfterWrite(5, TimeUnit.MINUTES)  // 写入后5分钟刷新
          .recordStats()  // 启用统计信息
          .removalListener((RemovalNotification<String, Integer> notification) -> {
              System.out.println("Removed key: " + notification.getKey() +
                                 ", cause: " + notification.getCause());
          })	// 缓存过期时触发函数
          .build(new CacheLoader<String, Integer>() {
              @Override
              public Integer load(String key) {	// 缓存项不存在时调用 load 函数
                  return computeExpensiveValue(key);// 自定义函数 computeExpensiveValue
              }
          });
  ```

### 3.2 [Caffeine](https://github.com/ben-manes/caffeine/wiki/Home-zh-CN)

> 查看[依赖](https://maven-badges.herokuapp.com/maven-central/com.github.ben-manes.caffeine/caffeine)

- 使用场景：适用于高并发、高性能要求的应用。

- 优点：高性能、更灵活的配置、支持基于权重的主动驱逐策略、拥有良好的统计信息，便于监控调优。

- 缺点：不支持持久化缓存。

- 配置方式：
  ```java
  Cache<String, Integer> cache = Caffeine.newBuilder()
          .maximumSize(100)  // 最大缓存容量
          .expireAfterWrite(Duration.ofMinutes(10))  // 写入后10分钟过期
          .expireAfterAccess(Duration.ofMinutes(5))  // 访问后5分钟过期
          .recordStats()  // 启用统计信息
          .weakKeys()  // 使用弱引用存储键
          .softValues()  // 使用软引用存储值
          .removalListener(new RemovalListener<String, Integer>() {
              @Override
              public void onRemoval(String key, Integer value, RemovalCause removalCause) {
                  System.out.println("Removed key: " + key +
                          ", value: " + value +
                          ", cause: " + removalCause);
              }
          })
          .build();
  ```

## 4.分布式缓存

### 4.1 [Redis](https://redis.io/docs/latest/commands/)

在 Java 中常见应用：

- 缓存
- 分布式会话管理
- 消息队列
- 分布式锁
- 数据持久化

[详细文档](./Redis.md)

### 4.2 [Memcached](https://github.com/memcached/memcached/wiki)

在 Java 中常见应用：

- 页面缓存
- 数据库查询缓存
- 会话管理
- 对象缓存

与 Java 应⽤程序集成：

- [Spymemcached](https://search.maven.org/search?q=g:net.spy%20AND%20a:spymemcached)：轻量级、简单易用的 Memcached 客户端，适合基本的缓存操作。
- [XMemcached](http://fnil.net/xmemcached/)：高性能的 Memcached 客户端，支持异步操作和高并发场景。

## 5.缓存⼀致性

### 5.1 概念

缓存一致性是指在分布式系统中，确保缓存中的数据与源数据（数据库或其他持久化存储）的状态保持一致的**过程**。

### 5.2 一致性问题

一致性问题通常出现在数据更新或删除时，因为缓存和源数据之间的同步可能存在延迟（网络延迟、系统故障等）或不一致。
因此，确保在设计时考虑到可能的异常情况并做相应的处理。

### 5.3 常见策略

#### 5.3.1 缓存失效

**策略**：当数据库中的数据发生变化时，确保相关的缓存数据被更新或删除，以保持一致性：

- **主动失效**：
  - **写操作时失效**：在对数据库执行写操作（如插入、更新、删除）时，同时更新或删除相关的缓存条目。
    	例如，当对 MySQL 中的数据进行更新时，通过代码逻辑立即更新或清除 Redis 中相应的缓存数据。
  - **使用触发器**：在 MySQL 数据库中使用触发器，当数据发生变化时，触发操作通知应用层更新或清除缓存。
- **定期失效**：
  - **定时刷新**：定期清除或更新缓存中的数据，但这种方法可能无法及时反映最新的数据库数据。

#### 5.3.2 缓存更新

**策略**：在数据库更新时直接修改缓存中的数据，以保持一致性：

- **更新缓存**：在数据库写操作**成功后**，立即更新 Redis 中的相关缓存数据。

#### 5.3.3 数据库与缓存同步

**策略**：在数据库和缓存之间保持同步，以保持一致性：

- **双写策略**：在对数据库进行写操作的**同时**，直接将写操作结果更新到 Redis 缓存中。
  	这种方法可以确保缓存和数据库数据同步，但需要确保操作的一致性（一方失败另一方取消）。

- **异步更新**：将写操作的更新请求异步发送到缓存和数据库中。

  ​	虽然这种方法可以减少写操作的延迟，但需要处理可能出现的延迟和一致性问题。

## 6.缓存策略

### 6.1 概念

缓存策略是决定缓存系统如何管理和使用缓存数据的规则。

### 6.2 常见缓存策略

#### 6.2.1 **替换策略**

当缓存空间不足时，决定哪些缓存条目需要被移除以腾出空间的策略。主要有：

- **最近最少使用（LRU）**：
  - **描述**：通过维护一个访问顺序或时间戳的队列（元素唯一），移除最近最少使用的数据（末端）。
  - **优点**：有效地利用时间局部性。
  - **缺点**：需要额外的时间和空间来跟踪访问记录。
- **先进先出（FIFO）**：
  - **描述**：移除最早存入缓存的数据。
  - **优点**：实现简单，不需要跟踪数据的使用情况。
  - **缺点**：可能会移除仍然频繁访问的数据。
- **最少使用（LFU）**：
  - **描述**：移除使用频率最低的数据。
  - **优点**：适用于访问频率高度不均的数据场景。
  - **缺点**：需要额外的计数机制来跟踪数据访问频率。

#### 6.2.2 **写策略**

决定如何处理缓存数据的写操作。主要有：

- **写直达**：
  - **描述**：在更新缓存数据时，同时更新主存储（数据库）。确保缓存和主存储中的数据始终保持一致。
  - **优点**：数据一致性高。
  - **缺点**：写操作的延迟较长，可能影响系统性能。
- **写回**：
  - **描述**：仅更新缓存中的数据，延迟写入主存储。数据在缓存中被修改后，只有在缓存条目被移除时才会更新主存储。
  - **优点**：写操作的性能较好。
  - **缺点**：可能会导致缓存与主存储数据不一致，增加了复杂性和一致性问题的风险。

#### 6.2.3 **失效策略**

决定缓存数据在何时失效的策略。主要有：

- **时间到期（TTL）**：
  - **描述**：为每个缓存条目设置一个生存时间，到期后缓存条目自动失效。过期的数据会被自动删除或更新。
  - **优点**：简单易用，可以有效地清理过时的数据。
  - **缺点**：可能导致数据被过早清除，影响缓存的有效性。
- **滑动过期**：
  - **描述**：缓存条目的过期时间是从最后一次访问时开始计算的。如果在过期时间内数据被访问，则过期时间会被重置。
  - **优点**：适用于频繁访问的数据，可以减少缓存过期带来的性能开销。
  - **缺点**：实现复杂度较高，可能导致内存占用过多。

#### 6.2.4 **填充策略**

决定缓存数据在需要时如何填充的策略。主要有：

- **惰性加载**：
  - **描述**：仅在缓存数据请求时才从主存储中加载数据。如果缓存数据失效，则在下次请求时重新加载数据。
  - **优点**：减少初始加载的开销，仅在需要时加载数据。
  - **缺点**：可能导致首次访问延迟较长。
- **预加载**：
  - **描述**：在缓存初始化或系统启动时，提前加载一部分或所有数据到缓存中。
  - **优点**：可以减少请求的延迟，保证数据在缓存中可用。
  - **缺点**：可能会消耗大量内存，加载时间较长。

#### 6.2.5 **一致性策略**

保证缓存数据与主存储数据一致的策略。主要有：

- **强一致性**：
  - **描述**：缓存和主存储始终保持一致，所有的写操作都立即同步到主存储。
  - **优点**：数据一致性最高。
  - **缺点**：写操作的延迟较长，可能影响系统性能。
- **最终一致性**：
  - **描述**：缓存和主存储数据最终会达到一致，但允许在短时间内存在不一致的状态。数据更新后，缓存和主存储会在一定时间内最	终一致。
  - **优点**：写操作性能较高，适用于数据一致性要求较低的场景。
  - **缺点**：可能会出现短时间的数据不一致。

#### 6.2.6 **备份策略**

决定缓存数据在失效或删除时如何备份的策略。主要有：

- **定期备份**：
  - **描述**：定期将缓存数据备份到持久存储中，以防数据丢失。
  - **优点**：可以恢复缓存数据，减少数据丢失的风险。
  - **缺点**：需要管理备份数据的存储和恢复过程。
- **事件驱动备份**：
  - **描述**：在特定事件（如数据更新）发生时，立即备份缓存数据。
  - **优点**：可以减少备份的延迟，提高数据安全性。
  - **缺点**：实现复杂，需要处理事件和备份逻辑。

## 7.缓存的设计与实现

### 7.1 设计缓存系统

#### 7.1.1 缓存的⼤⼩

缓存大小决定了可以存储多少数据，并直接影响缓存的性能和效率。确定缓存大小时考虑以下因素：

- **访问模式**：分析应用程序的访问模式，确定高频访问的数据量。使用统计数据或分析工具来估计缓存所需的大小。
- **内存限制**：根据系统的内存限制来分配缓存空间，确保缓存不会占用过多的内存，影响系统其他部分的性能。如果缓存的容量有限会引起缓存的失效，因此需要做好系统容量规划，以及是否可拓展，如分布式缓存。
- **数据压缩**：如果数据量较大，可以考虑数据压缩技术来节省内存空间，但要权衡压缩和解压缩的开销。

#### 7.1.2 过期策略

过期策略决定了缓存数据的生命周期和失效机制。选择合适的过期策略可以有效管理缓存的数据一致性和内存使用。常见的过期（失效）策略包括：

- **时间到期**
- **滑动过期**

#### 7.1.3 缓存粒度

缓存粒度决定了缓存数据的大小和管理方式。粒度的选择直接影响缓存的效率和复杂性。通常情况下缓存的粒度越小，命中率越高。比如说缓存一个用户信息的对象，只有当这个用户的信息发生变化的时候才更新缓存，而如果是缓存一个集合的话，集合中任何一个对象发生变化都要重新更新缓存。当数据发生变化时，直接更新缓存的值比移除缓存或者让缓存过期它的命中率更高，不过这个时候系统的复杂度过高。常见的粒度策略包括：

- **对象级别**：
  - **描述**：将整个对象作为缓存单元。
  - **优点**：简单直观，适用于需要缓存完整对象的场景。
  - **缺点**：如果对象很大，可能导致内存占用较高。
- **字段级别**：
  - **描述**：缓存对象的单个字段或属性，例如只缓存用户的姓名。
  - **优点**：节省内存空间，适合仅需要部分数据的场景。
  - **缺点**：需要更多的缓存管理和协调工作。
- **页面级别**：
  - **描述**：缓存网页或页面片段。
  - **优点**：适用于Web应用，能提高页面加载速度。
  - **缺点**：可能需要处理动态内容的更新和缓存失效问题。
- **查询级别**：
  - **描述**：缓存特定的数据库查询结果。
  - **优点**：减少数据库查询负载，提高查询性能。
  - **缺点**：需要处理缓存中查询结果的更新和一致性问题。

#### 7.1.4 其他设计

- **缓存一致性**
- **缓存预热**：在系统启动或缓存清空时，提前加载重要数据到缓存中，以减少首次访问的延迟。
- **缓存回填**：当缓存数据失效时，从数据库重新加载数据并填充缓存。
- **缓存监控和分析**：监控缓存的性能、使用情况和命中率，分析缓存效果，优化缓存策略。

### 7.2 实现缓存逻辑

```java
public static void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
    // 手动加载缓存
    Cache<String, String> manualCache = Caffeine.newBuilder()
            .expireAfterWrite(Duration.ofMinutes(10))
            .maximumSize(10_000)
            .build();
    // 获取缓存
    String element1 = manualCache.getIfPresent("key");   // 缓存未命中时返回null
    log.info("e1：{}", element1);
    String element2 = manualCache.get("key", key -> createTempString(key)); // 缓存未命中时生成缓存元素，无法生成则返回null
    log.info("e2：{}", element2);
    // 更新缓存
    manualCache.put("key", "newCache");
    String element3 = manualCache.getIfPresent("key");
    log.info("e3：{}", element3);
    // expireAfterWrite(Duration.ofMinutes(10)) 意味写入后10分钟失效
    // 手动失效
    manualCache.invalidate("key");
    String element4 = manualCache.getIfPresent("key");
    log.info("e4：{}", element4);

    // 自动加载缓存
    LoadingCache<String, String> autoCache = Caffeine.newBuilder()
            .expireAfterWrite(Duration.ofMinutes(10))
            .maximumSize(10_000)
            .build((String key) -> autoCache(key)); // 与手动加载不同，每一个元素在不存在缓存时lambda表达式会自动生成缓存
    String element5 = autoCache.get("key");
    log.info("e5：{}", element5);
}

public static String createTempString(String key) {
    return key + "TempCache";
}

public static String autoCache(String key) {
    return key + "AutoCache";
}
```

## 8.实际案例和最佳实践

《[苍穹外卖](https://www.bilibili.com/video/BV1TP411v7v6/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=30e2da7e9f03e3196cbc97c308d5ef80)》